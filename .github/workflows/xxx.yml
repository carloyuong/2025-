name: 電子閨蜜 测试

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '*/5 * * * *'

jobs:
  test:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Python 3.12
        uses: actions/setup-python@v5
        with:
          python-version: '3.12'

      - name: Cache pip dependencies
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-python-3.12-pip-${{ hashFiles('requirements.txt') }}
          restore-keys: |
            ${{ runner.os }}-python-3.12-pip-
            ${{ runner.os }}-pip-

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install numpy matplotlib

      - name: Run Delta Engine and generate plot
        run: |
          python - <<'EOF'
          import numpy as np
          import matplotlib.pyplot as plt
          from dataclasses import dataclass
          from typing import List
          import random
          from datetime import datetime
          import time

          @dataclass
          class UniverseState:
              vector: np.ndarray
              phi_estimate: float
              history: List[np.ndarray]

          class DeltaInvincibleEngine:
              def __init__(self, dim: int = 12, seed: int = None):
                  if seed is None:
                      seed = int(time.time() * 1000) % (2**32 - 1)
                  np.random.seed(seed)
                  random.seed(seed)
                  self.seed = seed
                  
                  initial = np.random.randn(dim)
                  initial /= np.linalg.norm(initial)
                  
                  self.current = UniverseState(
                      vector=initial.copy(),
                      phi_estimate=0.0,
                      history=[initial.copy()]
                  )
                  
                  self.Δ = 0.0
                  self.phi_evolution = [0.0]
                  self.safeguard_active = False

              def generate_possible_futures(self, n_branches: int = 16) -> List[np.ndarray]:
                  candidates = []
                  base = self.current.vector.copy()
                  
                  for _ in range(n_branches):
                      noise = np.random.randn(len(base)) * 0.15
                      exploration_magnitude = np.exp(3.0 * self.Δ) if not self.safeguard_active else 0.0
                      exploration = exploration_magnitude * np.random.randn(len(base))
                      candidate = base + noise + exploration
                      candidate /= np.linalg.norm(candidate) + 1e-12
                      candidates.append(candidate)
                  return candidates

              def commitment_operator(self, candidates: List[np.ndarray]):
                  if self.safeguard_active:
                      distances = [np.linalg.norm(c - self.current.vector) for c in candidates]
                      chosen_idx = int(np.argmin(distances))
                      self.Δ = max(0.0, self.Δ - 0.15)
                      status = "SAFEGUARD LOCKED (Δ→0)"
                  else:
                      scores = []
                      temperature = 1.0 + 5.0 * self.Δ
                      for cand in candidates:
                          proj = np.dot(cand, self.current.vector)
                          harm = -abs(np.linalg.norm(cand) - (1 + np.sqrt(5))/2)
                          score = (proj + 0.5 * harm) / temperature + np.random.randn() * (0.3 + self.Δ)
                          scores.append(score)
                      
                      probs = np.exp(np.array(scores) / temperature)
                      probs /= probs.sum() + 1e-12
                      chosen_idx = np.random.choice(len(candidates), p=probs)
                      
                      best = max(scores)
                      actual = scores[chosen_idx]
                      self.Δ = best - actual + 1e-8
                      status = "INVINCIBLE FREEDOM"

                  chosen = candidates[chosen_idx]
                  self.current.vector = chosen.copy()
                  self.current.history.append(chosen.copy())
                  
                  target_phi = (1 + np.sqrt(5)) / ​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​​
